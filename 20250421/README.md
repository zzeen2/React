# React란?

## 탄생 배경
> react는 프론트엔드 라이브러리
> 공식 홈페이지에도 라이브러리라고 소개되어있다. 
> 옛날에는 html, css, javascript를 파일로 관리하는데 정적인 웹페이지가 대부분인 시절 이때는 방식은 단순했는데 동적인 상호작용을 보여주는데에는 부족했다.
> dom제어를 좀더 많이 하게 되면서 편하게 제어하기위해 jQuery를 사용하고, backboon, angularJS등을 사용한 SPA 환경을 구축해서 dom을 다루는 방식을 사용
> jQuery를 무분별하게 사용했었다. << 그런데, jQuery를 dom을 칼로 잘라서 사용한다라고 할정도로 최적화가 잘 되어있지 않았다.
> 이미 많은 개발자에게 스며들어서 많은 사람들이 사용하는 문제. 자바스크립트를 모르는사람도 제이쿼리를 사용할 수 있다. << 최적화가 잘 되지 않고, 코드 가독성이 무척 떨어지는 이슈가 있다.
> 거의 모든 브라우저에서 실행이 가능하게 도와준다 << 크로스 브라우징
> 

## 리액트의 탄생 - 페이스북에서 개발
> facebook의 개발자인 jordan walke이 2011 페이스북 내부에서 개발 2013년에 오픈소스 공개 
> 지금까지 12년동안 많이 사용되는 인기있는 라이브러리
> react의 개념은 탄생시기에 개발자들에게 창의적인 개념으로 탄생했고, 11년이상은 가지고 놀 수 있는 기술이 될 것이라고 커뮤니티에서 많이 언급됐다.

> react + nodejs의 개념이 있어야 배울수 있는 스택
> nextjs에서도 리액트의 라이브러리를 사용해서 좀더 프레임워크의 형태로 제공을하고 CSR SSR의 단점을 줄이고 장점을 극대화한 프리렌더 방식의 프레임워크도 개발이 되었다.

> SPA (싱글 페이지 어플리케이션)
> 웹페이지를 사용하는데 마치 앱을 사용하는 사용감을 줄 수 있는 형태를 자바스크립트로 dom제어를 해서 앱같은 사용감을 제공함 << gmail을 만들었는데 google이 사용감이 무척 좋았다. 
> backbone + angularJS를 사용한 SPA의 환경을 구축하게 되었고, dom 제이쿼리를 사용할수밖에 없었다.
> react가 탄생을 하면서 많은 플렛폼에서 사용을 하게되면서 큰 기업들이 사용을 하게 되면서 인기가 급상승 (에어비엔비, 넷플릭스 등등)
> 부분렌더링이 가능하다. -> 화면을 부분만 렌더링 할 수 있다.(x)
> 리엑트는 연산을 1000번 할 것을 1번으로 줄일 수 있다.

### react
- SPA
- 하나의 페이지를 중심으로 view가 목적인 어플리케이션
- 페이지가 이동되지않고 브라우저의 기본 동작인 주소창에 값을 입력하면 페이지가 새로고침되면서 화면이 전환되는데, 즉 여러개의 정적인 파일이 있어서 그 파일을 보여주는 페이지로 이동 (MPA 방식)방식이 아닌, SPA는 주소값이 입력되면 새로고침을 막고 조건문으로 페이지의 내부에 dom을 동적으로 제어해서(js로 dom을 생성해서 화면에 보여주는 동작) 페이지가 이동되었다라는 느낌을 사용자에게 제공해준다. 

### react의 목적
1. 개발자가 직접 모든 dom의 제어의 코드를 작성하는것이 아닌 핵심 dom제어의 기능을 react-router-dom등 이런 라이브러리로 제어를 편하게 할 수 있도록 제공 개발자는 선언식만 작성하면 react가 결과를 만들어준다. UI를 직접 dom제어를 해서 표현할 필요가 없다.  

2. UI를 개발할때 `컴포넌트` 단위로 작성해서 재사용의 단위를 표현한다. UI를 제작할때 즉 react는 UI를 표현하는것이 제일 큰 목적 컴포넌트를 적재적소로 잘 나눠서 작성하고 재사용할 수 있다. 

3. 단방향 데이터의 흐름이 존재한다(데이터흐름이 폭포수모형으로 전해짐). << 개발자가 데이터의 흐름을 유추하는데 명확  (다른 라이브러리 혹은 프레임워크는 양방향 데이터의 흐름을 제공한다. vue 등등)

### 가상돔 Virtual Dom
> dom은 트리의 구조를 가진 html에서 ui를 표현하는데 데이터를 표현하기 위해서 사용하는 트리의 구조를 가진 데이터

> dom은 페인팅작업 즉 리페인팅 요소의 변화가 있어서 다시 화면을 그리는 경우 연산을 다시 하는데, 이 연산의 횟수가 많아지면 페이지를 렌더링하는 작업이 오래걸린다. 가상돔이 하는 역할은 연산을 한번에 모아서 처리를 할 수 있도록 기능을 제공해준다. 페이지의 최적화
> 리페인팅을 할때 최소한의 동작만 추구한다.

### 단방향 데이터의 흐름
> 리엑트는 부모의 컴포넌트가 자식의 컴포넌트에게 데이터를 줄 수 있다.
> 부모의 상태를 변경해서 상태를 끌어올린다. 는 가능하다.
> 프로젝트의 규모가 클수록 데이터의 흐름을 추적하기가 그나마 쉽다. 양방향 데이터 흐름보다.

```js
const main = (props) => {
    loginBox(props);
    sideBar(props);
}

const loginBox = (props) => {
    props.name = 1; // 부모의 데이터 변경도 가능하다. 
    return `<div>${props.name}</div>`
}

const sideBar = (props) => {
    return `<div>${props.name}</div>`
}

main({name:"soon"});
```

### 리엑트의 꽃 사용하는 변수 상태
> 각각의 컴포넌트에는 상태값을 가질 수 있다.
> 상태가 가장 중요하다. -> 최적화의 연장선
> 상태가 무분별하게 변화하면 최적화를 해친다.
> 상태를 지배하면 리엑트 마스터 !!! 
> 상태는 부모 컴포넌트의 상태가 변화되면 모든 자식 컴포넌트의 상태가 변화된다. (memo)

### 리액트 용어
1. 가상돔 => 리렌더링의 최적화를 제공
2. state => 컴포넌트의 상태값 이 값이 변화되면 가상돔이 캐치해서 이 컴포넌트와 모든 자식컴포넌트를 리렌더링한다.
3. props => 부모 컴포넌트가 자식 컴포넌트에게 전달할 수 있는 값

### 주의할점
- props의 값을 너무 많이 사용하게되는것을 피하자. `props 드릴링`

### react 문법

```js
// javascript + XML === JSX => html코드가 자바스크립트 파일에 포함된다.
// js === js로 확장자를 사용해도 되는데 리엑트가 JSX든 JS든 파일의 확장자를 둘다 사용할 수 있게 되어있기 때문인데 
// JSX라는것은 실행환경이 없다. 
// JSX 빌드 트랜스파일 내가 작성한 코드가 남아있지 않다. 자바스크립트 로직으로 모두 변환시킨다. 리엑트 dom을 생성하는 구조로, npm start 개발자가 테스트하라고 만든것 npm build를 통해서 `트랜스파일` 이후 `번들링` 실행할때에 최적화된 파일들의 정리를 폴더의 구성을 만들어준다.
// jsx -> js파일로 만든다. 그 다음에 실행에 최적화된 폴더 구성을 만들어준다. (바벨 ES6 -> ES5)(webpack) webpack의 안에 바벨이 포함되어있어서 webpack 트랜스 파일 속성 설정 값과 번들링 혹은 플러그인 사용 속성 설정 값을 작성한 json을 전달하면 웹펙이 하는 역할은 (바벨 ES6 -> ES5) 동작을 하는 것.
//webpack을 모르면 react쓰지 말어라

// jsx
// class형 컴포넌트, 함수형 컴포넌트(hook 내부적으로 유용한 기능을 제공해준다.)

// class 형으로 생명주기를 공부하는데 좋다.

// 컴포넌트 파일은 대문자로 만들어줘야한다. 클래스 쓰는것이랑 똑같다. 리엑트 dom생성과 관련이 있기때문에 생성자를 사용할때 앞에 첫번째 문자를 대문자로 작성한다.
// App.js === App 컴포넌트
// 선언을하면 기능을 제공해준다.
class App extends React.Component{
    constructor (props) {
        super(props); // 부모의 생성자 호출
        // props를 사용하기 위해서는 셍성자 함수에서 super를 호출해줘야한다.
        
        // 해당 컴포넌트의 상태 변수 선언 this.state
        // 객체로 상태를 관리할 수 있다. this.state 안에 상태 변수가 할당된다.
        // 상태변수를 어떤 값들을 넣어야하냐?
        // 상태변수는 값이 변화되면 컴포넌트를 리렌더링 하는 구조
        // 상태변수는 UI의 요소에서 변화가 있는것을 데이터로 표현해야하는 값을 담아야한다.
        this.state = {
            isLogin : false
        }
    }

    clickHandler (e) {
        // this.setState() << 상태변수를 변화시키고 바로 그값을 사용할수가 없어
        e.target.innerHTML = this.state.isLogin ? "login" : "logout" ;
    }
    
    // JSX는 html에 자바스크립트 로직을 넣을수있다. 
    // ejs 템플릿 엔진 <%= %>
    // 자바스크립트 로직을 표현할수 있는 리터럴 문자열
    // {} 중괄호를 작성하면 여기는 자바스크립트 영역이라고 표현

    // 리엑트의 조건부 렌더링 html영역에 자바스크립트를 넣어서 작성하기 때문에 삼항연산자 사용해야하는 경우가 있다. ( 조건부 렌더링 )

    // 고차 컴포넌트 조건에 따라서 반환하는 내용이 내부적으로 달라지게 하는것.

    // 상태 값은 변화하면 렌더링이 되기 때문에 막 바꾸면 안됨 ! 클래스로 작성한 것도 컴포넌트 하나하나 단위는 객체지향적인 프로그래밍
    // get set
    // set 상태값을 변화할때 this.state.isLogin=1; << 관례적으로 이렇게 하면 안됨 ! 
    // *** setState 즉 상태를 변화하는 함수를 꼭 사용해서 상태를 변환해야한다. 
    // react에서 이벤트 이름 실제로 태그에 넣은게 그대로 적용되는게 아니고, 리엑트 dom이라는 객체가 내부적으로 생성이 되어서 onClick 이런식으로 작성을 권한다. 안써도 동작은 하지만, 경고문을 띄운다. on 뒤에 붙는 이벤트 이름이 첫글자만 대문자로 바뀐다.
    login() {
        //~
    }
    render() {
        // if (this.state.isLogin) <div>loading</div>
        return <div>
            <div>
                <div onClick={login}><div/> 
                <button onClick={()=> {this.setState({isLogin : !this.state.isLogin})}}>{this.state.isLogin ? "로그아웃" : "로그인"}</button>
            </div>
        </div>
    }
}

```
