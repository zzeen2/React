# 리엑트의 함수형 컴포넌트

## 리엑트는 초기에 class형 컴포넌트를 사용
> 2013년에 페이스북에서 공개를 하면서 처음 사용했던 컴포넌트는 class
> 생명주기나 상태를 제어할때 클래스형 컴포넌트를 사용해야했다.

```jS
class App extends React.Component {
    render () {
        <div></div>
    }
}
```
## 클래스형 컴포넌트를 사용할때 어려웠던 점
1. 클래스 문법에 익숙하지 않은 사람도 있고
2. 구조가 복잡해진다. this 바인딩, render .. 
3. 구조의 재사용성이 많이 떨어진다. 코드가 너무 길어지고 무거워진다. 

## 처음에는 함수형 컴포넌트의 사용은 단순한 UI를 그릴때 
> 함수형 컴포넌트는 제공이 되었는데, 순수하게 UI를 그리는 함수 만으로 사용을 했었음
> 생명주기 함수나 상태제어 함수를 사용할 수 없었다.
```js
const App = () => {
    return <div><div/> 
    
}

```
### hook의 탄생
> 기능을 가져온다 라는 표현의 hook 즉 리액트의 기능을 가져와서 사용
> react가 16버전 이후부터 hook의 함수를 제공하게 되었다. 
> react의 기능을 사용할 수 있는 함수를 제공. 이 함수의 내용에는 유용한 기능이 포함되어 있다. 상태와 생명주기를 제어하기 위해.
> 클래스 컴포넌트에서만 생명주기와 상태를 다룰 수 있었지만, hook이 탄생하고 나서, 
> 함수형 컴포넌트에서도 생명주기와 상태 등의 더욱 상태를 제어하는데 강력한 함수를 제공해주게 되어서 함수형 컴포넌트의 사용도가 많아졌다.
*** 리액트의 공식문서에서 클래스형 컴포넌트를 배울 필요가 없다 ***
> 함수의 이름의 앞에 use가 붙으면 hook 함수이다.
> 리엑트에서 제공하지 않았지만 use가 붙은 함수는요? 커스텀훅 
> hook함수는 use를 꼭 붙여줘야 한다.
> hook 리엑틍에서 재사용이 많이 될것같은 기능을 구현할때 ( 입력창에 값을 입력해서 입력을 할때마다 상태를 업데이트 해서 상태 변수에 할다을 해놓는 기술 )

### 함수형 컴포넌트의 문법
```js
import {useState, useEffect } from "react"
// useState : 상태변수를 선언해서 사용할 수 있는 기능을 제공한다.
// useEffect 생명주기에서 호출할 기능을 정의. 콜백의 형태를 띄고있다. 
const App = () => {
    // count : 상태 변수 값
    // setCount 
    // useState : 초기 값
    const [count, setCount] = useState(0); // useState 반환값이 배열. 첫번째 요소는 상태 변수의 값, 두번째 요소는 상태변수를 업데이트 하는 함수

    // 내가 주시하는 상태가 변화했을때의 조건을 추가해서 실행해줄게
    // useEffect 생명주기에서 기능을 호출하는데 조건까지 어떤 상태변수가 변화하면 호출할 기능
    // useEffect 첫번째 매개변수로 콜백 함수를 전달해서 생명주기 때에 호출을 할수 있고, 두번째 매개변수로 배열의 값을 전달을 하는데 이 배열이 빈배열이면 마운트. 배열에 주시할 값을 전달하게 되면 마운트 + update 전달한 값이 변경될때마다 호출되는 값
    useEffect (() => {

    }, [])// 최초에 한번 호출 마운트

    useEffect (() => {

    }, [name])// 최초에 한번 호출 그리고 name이 값이 변화할때마다 호출

    useEffect (() => {
        if(count === 0 ) return  // 이런 조건을 작성하면 업데이트만.(마운트 제외)
        // 업데이트 구문을 사용
        return// 언마운트 컴포넌트가 화면에서 사라졌을때 보이지 않을때
    }, [count]) // 최초에 한번 호출 그리고 count의 값이 변화할때마다 호출

    useEffect (() => {
    }, [count, name])
    return <div>hello react<div> 
}
```

### 정리 
> 클래스 컴포넌트를 사용할때 문제점은 클래스의 문법의 이슈로 어려움을 겪었고 유지보수성 즉 가독성의 이슈와 재사용성의 이슈가 있었다.
> 함수형 컴포넌트를 사용하는 처음에는 단순하게 UI의 표현만 가능했지만 hook 함수가 탄생하고 나서 함수형 컴포넌트의 한계가 극복됨 + 기능 좋아짐 =>  함수형의 사용도가 높아졌다.

1. 코드의 구조는 클래스형은 this 바인딩이 필요하다. 함수형은 this가 없다. => 가독성 이슈
2. 상태 관리를 할 때 명확한 표현 this.state.count 클래스형/ 함수형은 이름이 명확하다.( setCount )
3. 생명주기 처리 생명주기 메서드를 선언해서 작성해야하는 방식과 다르게 기능의 구분이 명확하게 가능하다. useEffect는 생명주기를 사용하는데 명확한 상태의 주시가 가능하다. 업데이트의 로직을 코드를 구분을 정규화
4. 함수 기능의 재사용성. 클래스형은 재사용되는 기능을 정리하기 무리가 있다. 함수형 컴포넌트는 커스텀 hook 함수를 만들어서 재사용되는 기능을 작성해서 재사용성을 높일수 있다.
5. 부모가 리렌더링 되면 자식이 모두 리렌더링 되는데 클래스형에서 자식요소가 그려지는것에 대한 최적화에 제공되는 기능이 적다. 함수형은 useMemo useCallback 등 

### 함수형 컴포넌트로 가위바위보
1. 플레이어와 컴퓨터가 있고
2. 플레이어와 컴퓨터는 가위바위보를 선택할 수 있는데, 컴퓨터는 렌덤한 값을 가지고 선택ㅐ
3. 플레이어는 버튼을 눌러서 가위바위보 선택
4. 선택한 결과를 확인하는 때에는 플레이어가 버튼을 눌러서 가위바위보를 선택했을때 비교해서 승패 확인
