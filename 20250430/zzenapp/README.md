# 커스텀 훅
> 리액트에서 제공하는 hook들을 사용해서 기능을 한단계 더 추상화 시킨다.
> 로직과 텀포넌트 UI 구분을 위해서 사용
> 기능을 분리 단순하게 쉽게 말해서 함수다

### 커스텀 훅의 탄생
> 2018년도쯤 hook이 등장했고,
> useState, useEffect 이런 hook들이 등장한 시기 이후에 함수형 컴포넌트의 사용도가 올라갔고
> 이 함수형 컴포넌트의 사용 목적 : 코드의 간결성, 생명주기 제어, 재사용성이 좋은 기능들 제공됨

### 문제점 
> 기능의 재사용성을 높이는데 react hook만으로는 재사용성의 커버가 힘들었다.
> 복잡한 로직의 구분. 컴포넌트의 내용에 기능이 포함되다보면 모든 컴포넌트에서 재사용되는 기능들을 구분하기 힘들다.

### 커스텀 훅이 문제점 해결
> 리엑트 hook의 네이밍을 기반으로 우리가 직접 만든 함수로 공통 로직을 재사용성을 높여서 추상화 
> 이름은 use를 꼭 붙여서 제약을 걸고 사용해야한다. 리엑트는 커스텀훅을 만들때 use를 이름 앞에 꼭꼭 붙여줘야한다.
> useInput : 예) 입력값을 상태변수로 저장하고 있게하는 기능 

### 커스텀 훅의 목적성
- 로직의 재사용 : 여러 컴포넌트들에서 자주 사용되는 기능을 정의
- 컴포넌트와 기능의 분리 : 컴포넌트의 내부에 기능을 모두 작성하지 않고 유지보수와 코드의 가독성을 높이기 위해서 기능을 분리 

### 커스텀 훅의 동작 원리
> 리엑트 상태변수는 컴포넌트에서 hook이 호출될때 내부적으로 저장을 하는데, 
> 이 로직을 커스텀 훅에 상태를 저장해서 반환
> 기본 리엑트에서 제공하는 hook과 같은 규칙에 맞게 동작을 한다. 
```js
// 카운트 동작을 하는 컴포넌트는 모두 이 커스텀 훅을 재사용 할 수 있다.
// 커스텀 훅은 내부적으로 훅을 가지고 있고, 상태 변수의 변화를 컴포넌트에서 작성하지 않고 
// 훅을 사용한 상태변화를 통해 작성한 기능을 추상화 하는 역할을 한다.
const useCount = () => {
    const [count, setCount ] = useState(0);

    // 로직 처리를 내부에서 하고 내보냄
    // 기능의 추상화
    const increment = () => {
        setCount((prev => prev + 1))
    }

    return {count, increment};
}
```

### 모바일 버전 로그인 로직
> 입력값을 상태변수로 저장할 로직이 필요
> axios 요청 보낼 로직이 필요하고 ( 새로고침을 하지 않고 동적인 내용)
> 로딩에 대한 버튼의 ui

```sh
npm i axios
```